## <宿題１：ハッシュテーブル>
キーの何文字目かの記録をするcountを掛けることにより、アナグラム同士が同じハッシュ値を持つことを避けようと試みた。
ex) alice -> org(‘a’)*1 + org(‘l’)*2 + org(‘i’)*3 + org(‘c’)*4 + org(‘e’)*e5 
しかしここに素数をかけようと何をしようと実行時間が10秒に達することが多かった為、ビットシフトとの掛け合わせを試したところ大きく短縮することができた。
いずれの案でも複数のテストケースに生まれる差への解決策、また素数の利用よりビットシフトがより効果的な理由は思いついていない。
5月30日追記) キーの各桁に対して 10^(count-1) を掛けてみたら一番早く計算が終わった…代わりに、長いキーではハッシュ値の桁数が大きくなってしまうのではないかと懸念もしている

 ハッシュ値 \ テストケース        | 1      | 40    | 57     | 99   
 ------------------------------ | ------ | ----- | ------ | ----- 
 hash += ord(i) * count         | 0.0826 | 4.764 | 13.213 | 12.672
 hash += ord(i) << idx          | 0.0462 | 0.447 | 3.474  | 1.268
 hash += ord(i) * count << idx  | 0.0534 | 0.090 | 2.820  | 0.184
 hash += ord(i) *10^(count-1)   | 0.0380 | 0.026 | 1.432  | 0.030


 ## <宿題２：　ハッシュテーブル vs 木構造>
 # なぜ木構造が好まれるか
 ・ハッシュはメモリの使用量が多いから
衝突を減らすことを目的にテーブルのサイズがある程度確保されている為、実際には使われないメモリまで消費することになる
・関連性のあるデータを扱う際は木構造の方が優れているから
ハッシュテーブルは検索等が容易である反面、一つ一つのデータの関連性を無視している為、

